Кроме числовых и булева типов у Python есть несколько мощных встроенных составных классов. Списки, строки и кортежи являются упорядоченными коллекциями. Они весьма схожи по общей структуре, но имеют специфические различия, понимать которые необходимо для уместного их использования. К неупорядоченным коллекциям относятся множества и словари.

__Список__ - это упорядоченная коллекция из нуля или более ссылок на объекты данных Python. Списки записываются как разделённые запятыми значения, заключённые в квадратные скобки. Пустой список выглядит просто `[]`. Списки гетерогенны. Это означает, что их объекты не обязательно должны иметь один и тот же тип, и коллекция может быть присвоена переменной, как показано ниже. Следующий фрагмент показывает различные объекты данных Python, объединённые в список.

```python
>>> [1,3,True,6.5]
[1, 3, True, 6.5]
>>> myList = [1,3,True,6.5]
>>> myList
[1, 3, True, 6.5]
```

Обратите внимание, что результатом вычисления списка в Python является он сам. Тем не менее, чтобы запомнить список для последующей обработки, ссылка на него должна быть присвоена переменной.

Поскольку списки считаются последовательно упорядоченными, то они поддерживают ряд операций, которые могут быть применены к любой Python-последовательности. Эти операции собраны в _таблице 2_ вместе с примерами их использования.

### Таблица 2: Операции для любой последовательности в Python

Имя оператора | Оператор | Пояснение
---|---|---
индексирование | [ ] | Доступ к элементу последовательности
конкантенация | + | Объединение двух последовательностей
повторение | * | Конкатенация повторений заданное количество раз
принадлежность элемента | in | Запрос о принадлежности элемента данной последовательности
длина | len | Запрос количества элементов в последовательности
срез | [ : ] | Выделение части последовательности

Обратите внимание, что индексы элементов списка начинаются с 0. Операция среза `myList[1:3]` возвращает список, начинающийся с элемента под индексом 1, но при этом не включает в себя элемент под индексом 3.

Иногда у вас может возникнуть желание проинициализировать список. Этого легко достичь, используя повторения. Например,

```python
>>> myList = [0] * 6
>>> myList
[0, 0, 0, 0, 0, 0]
```

Одно важное отступление, касающееся оператора повторения: его результатом будет последовательность повторений ссылок на объект данных. Это хорошо видно в следующем примере:

```python
myList = [1,2,3,4]
A = [myList]*3
print(A)
# [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
myList[2]=45
print(A)
# [[1, 2, 45, 4], [1, 2, 45, 4], [1, 2, 45, 4]]
```

Переменная `А` содержит коллекцию из трёх ссылок на оригинальный список `myList`. Обратите внимание, что изменение одного элемента в `myList` отражается на всех трёх вхождениях в `А`.

Списки поддерживают ряд методов, которые будут использоваться для построения структур данных. В _таблице 3_ представлено обобщение методов для работы со списками. Ниже идут примеры их применения.

### Таблица 3: Методы, предусмотренные для списков в Python

Название метода | Использование | Пояснение
---|---|---
append | alist.append(item) | Добавить новый элемент в конец списка
insert | alist.insert(i,item) | Вставить элемент в i-ую позицию списка
pop | alist.pop() | Удалить из списка и вернуть последний элемент
pop | alist.pop(i) | Удалить из списка и вернуть i-й элемент
sort | alist.sort() | Отсортировать список (изменяет оригинал)
reverse | alist.reverse() | Изменить список, чтобы элементы шли в обратном порядке
del | del  alist[i] | Удалить элемент на i-й позиции
index | alist.index(item) | Вернуть индекс первого вхождения item
count | alist.count(item) | Вернуть число вхождений item в список
remove | alist.remove(item) | Удалить первое вхождения item

```python
myList = [1024, 3, True, 6.5]
myList.append(False)
print(myList)
# [1024, 3, True, 6.5, False]
myList.insert(2,4.5)
print(myList)
# [1024, 3, 4.5, True, 6.5, False]
print(myList.pop())
# False
print(myList)
# [1024, 3, 4.5, True, 6.5]
print(myList.pop(1))
# 3
print(myList)
# [1024, 4.5, True, 6.5]
myList.pop(2)
print(myList)
# [1024, 4.5, 6.5]
myList.sort()
print(myList)
# [4.5, 6.5, 1024]
myList.reverse()
print(myList)
# [1024, 6.5, 4.5]
print(myList.count(6.5))
# 1
print(myList.index(4.5))
# 2
myList.remove(6.5)
print(myList)
# [1024, 4.5]
del myList[0]
print(myList)
# [4.5]
```

Как вы можете видеть, некоторые методы (например, `pop`) возвращают значение и при этом модифицируют список. Другие (как `reverse`) просто изменяют список. По умолчанию `pop` применяется к концу списка, но может также удалять и возвращать конкретное значение. Для всех этих методов индексация по прежнему начинается с нуля. Вы также могли отметить знакомую "dot"-нотацию, запрашивающую у объекта вызов метода. `myList.append(False)` можно прочитать как "запросить у объекта `myList`, выполнить его метод `append`, с чей помощью добавить в список значение `False`". Даже такие простые объекты данных, как целые числа, могут вызывать свои методы подобным образом.

```python
>>> (54).__add__(21)
75
>>>
```

В этом фрагменте мы просим объект целочисленного типа `54` выполнить его метод `add` (в Python называется `__add__`), передав в него `21`, как число, которое нужно прибавить. Результатом будет сумма `75`. Конечно, обычно мы это пишем как `54+21`. Подробнее об этих методах мы поговорим чуть позже.

Ещё одной распространённой функцией, часто обсуждаемой в связке со списками, является функция `range`. Она производит объект "диапазон", представляющий из себя последовательность значений. Используя функцию `list`, можно представить значение такого объекта в виде списка. Это проиллюстрировано ниже:

```python
>>> range(10)
range(0, 10)
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(5,10)
range(5, 10)
>>> list(range(5,10))
[5, 6, 7, 8, 9]
>>> list(range(5,10,2))
[5, 7, 9]
>>> list(range(10,1,-1))
[10, 9, 8, 7, 6, 5, 4, 3, 2]
>>>
```

Объект "диапазон" представляет из себя последовательность целых чисел. По умолчанию он начинается с нуля. Если вы предоставите больше параметров, то он будет начинаться и заканчиваться в конкретных точках и сможет даже пропускать некоторые элементы. В нашем первом примере - `range(10)` - последовательность начинается с `0` и продолжается до `9` (не включая `10`). Во втором примере - `range(5,10)` - начинается с `5` и заканчивается `9` (опять же, не включая `10`). `range(5,10,2)` работает аналогично, но пропускает каждый второй элемент (`10` по прежнему не включается).

__Строки__ представляют собой коллекции с последовательным доступом из нуля или более букв, чисел и прочих знаков. Мы называем все эти элементы символами. Строковый литерал отличается от идентификатора использованием кавычек (одинарных или двойных).

```python
>>> "David"
'David'
>>> myName = "David"
>>> myName[3]
'i'
>>> myName*2
'DavidDavid'
>>> len(myName)
5
>>>
```

Поскольку строки - это последовательности, то все описанные выше операции будут с ними работать так, как ожидается. Дополнительно у строк есть ещё несколько методов, некоторые из которых представлены в _таблице 4_. Например,

```python
>>> myName
'David'
>>> myName.upper()
'DAVID'
>>> myName.center(10)
'  David   '
>>> myName.find('v')
2
>>> myName.split('v')
['Da', 'id']
```

Из них очень полезным для обработки данных является метод `split`. Он принимает строку и возвращает список строк, используя расщепляющий символ как точку разделения. В нашем примере таковым является `v`. Если разделитель не указан, то `split` ищет пробельные символы (табуляции, переходы на новую строку и пробелы).

### Таблица 4: Методы, предусмотренные для строк в Python

Название метода | Использование | Пояснение
---|---|---
`center` | `astring.center(w)` | Возвращает строку, центрированную в поле размера `w`
`count` | `astring.count(item)` | Возвращает число вхождений `item` в строку
`ljust` | `astring.ljust(w)` | Возвращает строку с выравниванием по левому краю поля размером `w`
`lower` | `astring.lower() |` Возвращает строку из символов в нижнем регистре
`rjust` | `astring.rjust(w)` | Возвращает строку с выравниванием по правому краю поля размером `w`
`find` | `astring.find(item)` | Возвращает индекс первого вхождения `item`
`split` | `astring.split(schar)` | Разбивает строку на подстроки по символу `schar`

Основное различие между списками и строками заключается в том, что списки можно изменять, а строки - нет. Это свойство называется __мутабельностью__. Списки мутабельны, строки иммутабельны. Например, вы легко можете изменить элемент списка, используя индексацию и присваивание. Для строк такие операции не допускаются.

```python
>>> myList
[1, 3, True, 6.5]
>>> myList[0]=2**10
>>> myList
[1024, 3, True, 6.5]
>>>
>>> myName
'David'
>>> myName[0]='X'

Traceback (most recent call last):
  File "<pyshell#84>", line 1, in -toplevel-
    myName[0]='X'
TypeError: object doesn't support item assignment
>>>
```
